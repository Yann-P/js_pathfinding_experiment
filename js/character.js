// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['jquery', 'utils', 'data', 'entity'], function($, Utils, Data, Entity) {
    var Character;
    return Character = (function(_super) {

      __extends(Character, _super);

      function Character(id, kind) {
        this.moveStack = [];
        this.orientation = 'down';
        this.requestedPathCallback = null;
        this.beforeNextStepCallback = null;
        this.stepCallback = null;
        this.deathCallback = null;
        this.currentMoveTimeout = null;
        this.mvmtInProgress = false;
        this.target = null;
        this.attackers = {};
        Character.__super__.constructor.call(this, id, kind);
        this.setup();
      }

      Character.prototype.setup = function() {
        var healthBar;
        this.healthBar = healthBar = document.createElement('div');
        $(healthBar).addClass('health-bar');
        $(this.elt).addClass('character').append(healthBar);
        return this.setAnimation('idle_down');
      };

      Character.prototype.follow = function(character) {
        return this.moveTo(character.x, character.y);
      };

      Character.prototype.recalculatePath = function() {
        var destination;
        console.log("Recalcul du chemin");
        if (this.moveStack.length === 0) {
          throw "Impossible de recalculer le chemin. Aucun mvmt en cours.";
        }
        destination = this.moveStack[this.moveStack.length - 1];
        return this.moveTo(destination[0], destination[1]);
      };

      Character.prototype.setTarget = function(character) {
        if (this.target) {
          this.removeTarget();
        }
        return this.target = character;
      };

      Character.prototype.removeTarget = function() {
        this.target = null;
        return this.abortMove();
      };

      Character.prototype.addAttacker = function(character) {
        var _ref;
        console.log(this.attackers);
        if (!(_ref = character.id, __indexOf.call(this.attackers, _ref) >= 0)) {
          return this.attackers[character.id] = character;
        } else {
          throw 'Déjà attaqué par ce personnage';
        }
      };

      Character.prototype.removeAttacker = function(character) {
        var _ref;
        if (_ref = character.id, __indexOf.call(this.attackers, _ref) >= 0) {
          return delete this.attackers[character.id];
        } else {
          throw 'Pas attaqué par ce personnage';
        }
      };

      Character.prototype.forEachAttacker = function(callback) {
        var id, _results;
        _results = [];
        for (id in this.attackers) {
          _results.push(callback(this.attackers[id]));
        }
        return _results;
      };

      Character.prototype.damage = function(hp) {
        this.health -= hp;
        if (this.health <= 0) {
          this.hp = 0;
          return this.die();
        }
        return this.updateHealthBar();
      };

      Character.prototype.heal = function(hp) {
        this.health += hp;
        if (this.health > this.maxHealth) {
          this.health = this.maxHealth;
        }
        return this.updateHealthBar();
      };

      Character.prototype.updateHealthBar = function() {
        var _this = this;
        $(this.healthBar).css('background', 'white');
        return setTimeout(function() {
          return $(_this.healthBar).css({
            background: 'red',
            width: (_this.health / _this.maxHealth) * 30
          });
        }, 100);
      };

      Character.prototype.die = function() {
        return this.onDeathCallback();
      };

      Character.prototype.setMoveStack = function(moveStack) {
        console.log("Setmovestack avec (" + moveStack[0][0] + ", " + moveStack[0][1] + ") comme source");
        this.moveStack = moveStack;
        if (!this.mvmtInProgress) {
          console.log("Pas de mouvement en cours, nextMove()");
          return this._nextMove();
        }
      };

      Character.prototype.abortMove = function() {
        console.log(("AbortMove en (" + this.x + ", " + this.y + "). Timeout cleared : ") + this.currentMoveTimeout);
        window.clearTimeout(this.currentMoveTimeout);
        return this.moveStack = [];
      };

      Character.prototype.move = function(x, y, callback) {
        var _this = this;
        this.setPosition(x, y);
        this.currentMoveTimeout = window.setTimeout(function() {
          console.log("Timeout just executed : " + _this.currentMoveTimeout);
          return callback();
        }, 1000);
        return console.log("Timeout just set : " + this.currentMoveTimeout);
      };

      Character.prototype.moveTo = function(x, y) {
        var path;
        console.log("MoveTo depuis (" + this.x + ", " + this.y + ") jsq (" + x + ", " + y + ")");
        path = this.requestedPathCallback(x, y);
        return this.setMoveStack(path);
      };

      Character.prototype.moveTowards = function(direction, callback) {
        var pos,
          _this = this;
        pos = {
          x: this.x,
          y: this.y
        };
        switch (direction) {
          case 'left':
            pos.x--;
            break;
          case 'right':
            pos.x++;
            break;
          case 'up':
            pos.y--;
            break;
          case 'down':
            pos.y++;
        }
        this.setAnimation("move_" + direction);
        this.orientation = direction;
        this.mvmtInProgress = true;
        return this.move(pos.x, pos.y, function() {
          _this.mvmtInProgress = false;
          return callback();
        });
      };

      Character.prototype._nextMove = function() {
        var dest, direction, source,
          _this = this;
        if (this.moveStack.length <= 1) {
          return this.idle();
        }
        source = this.moveStack[0];
        dest = this.moveStack[1];
        console.log("NextMove. moveStack actuel : " + JSON.stringify(this.moveStack));
        direction = null;
        if (source[0] !== this.x || source[1] !== this.y) {
          throw "La source (" + source[0] + ", " + source[1] + ") n'est pas la position actuelle du Character (" + this.x + ", " + this.y + ")";
        }
        if (Math.abs(source[0] - dest[0]) + Math.abs(source[1] - dest[1]) > 1) {
          throw "Il doit y avoir exactement une coordonnée changée de source à dest, x OU y";
        }
        if (source[0] - dest[0] === -1) {
          direction = 'right';
        } else if (source[0] - dest[0] === 1) {
          direction = 'left';
        } else if (source[1] - dest[1] === -1) {
          direction = 'down';
        } else if (source[1] - dest[1] === 1) {
          direction = 'up';
        } else {
          throw "Mouvement inconnu";
        }
        this.moveTowards(direction, function() {
          _this.beforeNextStepCallback(_this.moveStack[1][0], _this.moveStack[1][1]);
          return _this._nextMove();
        });
        this.stepCallback(source[0], source[1]);
        return this.moveStack.splice(0, 1);
      };

      Character.prototype.enableSmoothMvmt = function() {
        $(this.elt).addClass('smooth-mvmt');
        Utils.setTransitionDuration(this.elt, 1 / this.speed);
        return window.getComputedStyle(this.elt).getPropertyValue("left");
      };

      Character.prototype.disableSmoothMvmt = function() {
        return $(this.elt).removeClass('smooth-mvmt');
      };

      Character.prototype.onRequestedPath = function(callback) {
        return this.requestedPathCallback = callback;
      };

      Character.prototype.onBeforeNextStep = function(callback) {
        return this.beforeNextStepCallback = callback;
      };

      Character.prototype.onStep = function(callback) {
        return this.stepCallback = callback;
      };

      Character.prototype.onDeath = function(callback) {
        return this.onDeathCallback = callback;
      };

      Character.prototype.idle = function() {
        console.log("idle");
        return this.setAnimation("idle_" + this.orientation);
      };

      Character.prototype.remove = function() {
        console.log("Remove character");
        this.abortMove();
        return Entity.prototype.remove.call(this);
      };

      return Character;

    })(Entity);
  });

}).call(this);
