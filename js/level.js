// Generated by CoffeeScript 1.3.3
(function() {

  define(['jquery', 'astar', 'data', 'utils', 'map', 'zombie', 'villager', 'tower', 'effect', 'wave', 'entity'], function($, AStar, Data, Utils, Map, Zombie, Villager, Tower, Effect, Wave, Entity) {
    var Level;
    Level = (function() {

      function Level(id, app) {
        this.id = id;
        this.app = app;
        this.entityCount = 0;
        this.entities = {};
        this.currentWaveId = 0;
        this.waves = [];
        this.map = new Map();
        this.setup();
      }

      Level.prototype.setup = function() {
        var data;
        data = Data.store.levels[this.id] || (function() {
          throw "Données manquantes pour level #" + this.id;
        }).call(this);
        this.name = data.name, this.gold = data.gold, this.blocking = data.blocking, this.initialTowers = data.initialTowers;
        $('#game').css('backgroundImage', "url('resources/img/maps/" + this.name + ".png')");
        this.wavesData = data.waves;
        this.addWaves();
        this.map.setBlockingGrid(this.blocking);
        this.addInitialTowers();
        return this.nextWave();
      };

      Level.prototype.addInitialTowers = function() {
        var tower, towerData, _i, _len, _ref, _results;
        tower = null;
        _ref = this.initialTowers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          towerData = _ref[_i];
          tower = this.addTower(towerData.x, towerData.y, towerData.kind);
          _results.push(tower.setUpgradeLevel(towerData.upgradeLevel || 0));
        }
        return _results;
      };

      Level.prototype.addWaves = function() {
        var id, wave, waveData, _i, _len, _ref, _results;
        _ref = this.wavesData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          waveData = _ref[_i];
          id = this.waves.length;
          wave = new Wave(id, waveData.zombies, waveData.interval, waveData.next, this);
          _results.push(this.waves[id] = wave);
        }
        return _results;
      };

      Level.prototype.nextWave = function() {
        var _this = this;
        this.waves[this.currentWaveId].start(function() {
          if (_this.currentWaveId < _this.waves.length) {
            return _this.nextWave();
          } else {
            return console.log("Toutes vagues envoyées");
          }
        });
        return this.currentWaveId++;
      };

      Level.prototype.createAttackLink = function(attacker, target) {
        attacker.setTarget(target);
        attacker.follow(target);
        return target.addAttacker(attacker);
      };

      Level.prototype.effectAt = function(effectid, x, y) {
        var effect,
          _this = this;
        effect = new Effect(this.entityCount++, effectid, false);
        this.entities[effect.id] = effect;
        return effect.playAt(x, y, function() {
          return _this.removeEntity(_this.entities[effect.id]);
        });
      };

      Level.prototype.addZombie = function(x, y, kind) {
        var zombie;
        zombie = new Zombie(this.entityCount++, kind);
        zombie.setPosition(x, y);
        this.addCharacterCallback(zombie);
        return zombie;
      };

      Level.prototype.addVillager = function(x, y, kind) {
        var villager;
        villager = new Villager(this.entityCount++, kind);
        villager.setPosition(x, y);
        this.addCharacterCallback(villager);
        return villager;
      };

      Level.prototype.addTower = function(x, y, kind) {
        var amount, door, i, tower, type, _i, _ref,
          _this = this;
        tower = new Tower(this.entityCount++, kind);
        tower.setPosition(x, y);
        this.map.addBlockingItem(tower.x, tower.y, tower.width, tower.height);
        tower.onRemove(function() {
          return _this.map.removeBlockingItem(tower.x, tower.y, tower.width, tower.height);
        });
        door = new Entity(this.entityCount++, tower.door.spriteid);
        door.setPosition(tower.x + tower.door.x, tower.y + tower.door.y);
        door.setAnimation('opening', 1);
        _ref = tower.villagers;
        for (type in _ref) {
          amount = _ref[type];
          for (i = _i = 0; 0 <= amount ? _i < amount : _i > amount; i = 0 <= amount ? ++_i : --_i) {
            this.addVillager(door.x, door.y, type);
          }
        }
        return tower;
      };

      Level.prototype.addCharacterCallback = function(character) {
        var pos,
          _this = this;
        this.entities[character.id] = character;
        character.enableSmoothMvmt();
        if (!this.map.isTileFree(character.x, character.y)) {
          pos = this.map.getNearestFreeTile(character.x, character.y);
          character.setPosition(pos[0], pos[1]);
        }
        this.map.addBlockingItem(character.x, character.y);
        character.onStep(function() {
          return character.forEachAttacker(function(attacker) {
            return attacker.follow(character);
          });
        });
        character.onRequestedPath(function(x, y) {
          return _this.findPath(character, x, y);
        });
        return character.onDeath(function() {
          return _this.removeEntity(character);
        });
      };

      Level.prototype.removeEntity = function(entity) {
        console.log("remove:");
        console.log(entity);
        entity.remove();
        return delete this.entities[entity.id];
      };

      Level.prototype.getAllZombies = function() {
        var id, zombies;
        zombies = {};
        for (id in this.entities) {
          if (this.entities[id] instanceof Zombie) {
            zombies[id] = this.entities[id];
          }
        }
        return zombies;
      };

      Level.prototype.findPath = function(character, x, y) {
        var path;
        path = this.map.findPath([character.x, character.y], [x, y]);
        if (path.length === 0) {
          console.log("Le personnage #" + character.id + " de type " + character.kind + " n'a pas trouvé de chemin jusque (" + x + ", " + y + ")");
        }
        return path;
      };

      Level.prototype.destroy = function() {
        var entity;
        for (entity in this.entities) {
          this.removeEntity[entity];
        }
        return this.waves[this.currentWaveId].stop();
      };

      return Level;

    })();
    return Level;
  });

}).call(this);
