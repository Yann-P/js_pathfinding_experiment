// Generated by CoffeeScript 1.3.3
(function() {

  define(['jquery', 'astar', 'data', 'utils', 'map', 'zombie', 'villager', 'tower', 'effect', 'wave', 'entity'], function($, AStar, Data, Utils, Map, Zombie, Villager, Tower, Effect, Wave, Entity) {
    var Level;
    Level = (function() {

      function Level(id, app) {
        var v1;
        this.id = id;
        this.app = app;
        this.entityCount = 0;
        this.entities = {};
        this.currentWaveId = 0;
        this.waves = [];
        this.map = new Map();
        this.setup();
        v1 = this.addVillager(5, 1, 'villager_1');
        v1.moveTo(18, 1);
      }

      Level.prototype.setup = function() {
        var data;
        data = Data.store.levels[this.id] || (function() {
          throw "Données manquantes pour level #" + this.id;
        }).call(this);
        this.name = data.name, this.gold = data.gold, this.blocking = data.blocking, this.initialTowers = data.initialTowers;
        $('#game').css('background', "lightyellow");
        this.wavesData = data.waves;
        this.addWaves();
        this.map.setBlockingGrid(this.blocking);
        this.addInitialTowers();
        return this.nextWave();
      };

      Level.prototype.addInitialTowers = function() {
        var tower, towerData, _i, _len, _ref, _results;
        tower = null;
        _ref = this.initialTowers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          towerData = _ref[_i];
          tower = this.addTower(towerData.x, towerData.y, towerData.kind);
          _results.push(tower.setUpgradeLevel(towerData.upgradeLevel || 0));
        }
        return _results;
      };

      Level.prototype.addWaves = function() {
        var id, wave, waveData, _i, _len, _ref, _results;
        _ref = this.wavesData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          waveData = _ref[_i];
          id = this.waves.length;
          wave = new Wave(id, waveData.zombies, waveData.interval, waveData.next, this);
          _results.push(this.waves[id] = wave);
        }
        return _results;
      };

      Level.prototype.nextWave = function() {
        var _this = this;
        this.waves[this.currentWaveId].start(function() {
          if (_this.currentWaveId < _this.waves.length) {
            return _this.nextWave();
          } else {
            return console.log("Toutes vagues envoyées");
          }
        });
        return this.currentWaveId++;
      };

      Level.prototype.createAttackLink = function(attacker, target) {
        attacker.setTarget(target);
        attacker.follow(target);
        return target.addAttacker(attacker);
      };

      Level.prototype.effectAt = function(effectid, x, y) {
        var effect,
          _this = this;
        effect = new Effect(this.entityCount++, effectid, false);
        this.entities[effect.id] = effect;
        return effect.playAt(x, y, function() {
          return _this.removeEntity(_this.entities[effect.id]);
        });
      };

      Level.prototype.addZombie = function(x, y, kind) {
        var zombie;
        zombie = new Zombie(this.entityCount++, kind);
        zombie.setPosition(x, y);
        this.addCharacterCallback(zombie);
        return zombie;
      };

      Level.prototype.addVillager = function(x, y, kind) {
        var villager;
        villager = new Villager(this.entityCount++, kind);
        villager.setPosition(x, y);
        this.addCharacterCallback(villager);
        return villager;
      };

      Level.prototype.addTower = function(x, y, kind) {
        var amount, door, i, tower, tvill, type, _i, _ref,
          _this = this;
        tower = new Tower(this.entityCount++, kind);
        tower.setPosition(x, y);
        this.map.addBlockingItem(tower.x, tower.y, tower.width, tower.height);
        tower.onRemove(function() {
          return _this.map.removeBlockingItem(tower.x, tower.y, tower.width, tower.height);
        });
        door = new Entity(this.entityCount++, tower.door.spriteid);
        door.setPosition(tower.x + tower.door.x, tower.y + tower.door.y);
        door.setAnimation('opening', 1);
        _ref = tower.villagers;
        for (type in _ref) {
          amount = _ref[type];
          for (i = _i = 0; 0 <= amount ? _i < amount : _i > amount; i = 0 <= amount ? ++_i : --_i) {
            tvill = this.addVillager(door.x, door.y, type);
            console.log(tvill.x + ' ' + tvill.y);
            tvill.moveTo(0, 0);
          }
        }
        return tower;
      };

      Level.prototype.addCharacterCallback = function(character) {
        var pos,
          _this = this;
        this.entities[character.id] = character;
        character.enableSmoothMvmt();
        if (!this.map.isTileFree(character.x, character.y)) {
          console.log("Un personnage a spawné dans un mur");
          pos = this.map.getNearestFreeTile(character.x, character.y);
          character.setPosition(pos[0], pos[1]);
        }
        this.map.addBlockingItem(character.x, character.y);
        character.onBeforeNextStep(function(nextX, nextY) {
          var coord, _i, _len, _ref, _results;
          console.log("$ beforeNextStep : actuellement en (" + character.x + ", " + character.y + "), prochaine case (" + nextX + ", " + nextY + ")");
          if (!_this.map.isTileFree(nextX, nextY)) {
            console.log("# Bloqué à (" + character.x + ", " + character.y + "), ne peut pas se rendre en (" + nextX + ", " + nextY + ")");
            character.abortMove();
            console.log("#######");
            character.moveTo(18, 1);
          }
          Utils.removeDebugEntities('path' + character.id);
          _ref = character.moveStack;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            coord = _ref[_i];
            _results.push(Utils.createDebugEntity(coord[0], coord[1], 'blue', -1, 'path' + character.id));
          }
          return _results;
        });
        character.onStep(function(prevX, prevY) {
          _this.map.removeBlockingItem(prevX, prevY);
          _this.map.addBlockingItem(character.x, character.y);
          console.log("$ step : passage de (" + prevX + ", " + prevY + ") à (" + character.x + ", " + character.y + ")");
          character.forEachAttacker(function(attacker) {
            return attacker.follow(character);
          });
          if (character.x === 6) {
            return _this.map.addBlockingItem(character.x + 2, character.y);
          }
        });
        character.onRequestedPath(function(x, y) {
          var path;
          path = _this.findPath(character, x, y);
          return path;
        });
        return character.onDeath(function() {
          return _this.removeEntity(character);
        });
      };

      Level.prototype.removeEntity = function(entity) {
        console.log("remove:");
        console.log(entity);
        entity.remove();
        return delete this.entities[entity.id];
      };

      Level.prototype.getAllZombies = function() {
        var id, zombies;
        zombies = {};
        for (id in this.entities) {
          if (this.entities[id] instanceof Zombie) {
            zombies[id] = this.entities[id];
          }
        }
        return zombies;
      };

      Level.prototype.findPath = function(character, x, y) {
        var path;
        path = this.map.findPath([character.x, character.y], [x, y]);
        if (path.length === 0) {
          path = this.map.findIncompletePath([character.x, character.y], [x, y]);
          if (path.length === 0) {
            console.log("Le personnage #" + character.id + " de type " + character.kind + " n'a pas trouvé de chemin jusque (" + x + ", " + y + ")");
          } else {
            console.log("Chemin incomplet");
            console.log(JSON.parse(JSON.stringify(path)).length);
            console.log(JSON.stringify(path));
            console.log(path.length);
            console.log(path);
            console.log("1re entrée : " + path[0]);
            console.log("/chemin incomplet");
          }
        }
        return path;
      };

      Level.prototype.destroy = function() {
        var entity;
        for (entity in this.entities) {
          this.removeEntity[entity];
        }
        return this.waves[this.currentWaveId].stop();
      };

      return Level;

    })();
    return Level;
  });

}).call(this);
